\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage[overload]{empheq}
\usepackage{color}
\usepackage[dvipsnames]{xcolor}
\usepackage{fullpage}

\title{PFSP heuristics project}

\author{Dorian Dumez}

\begin{document}
\maketitle

\section{Code}

\subsection{How to use}

In the code directory the command "make" can be use to compile the whole project. Beside "make clean" delete all .o files.

After compiling the project experiment can be done on a single instance with "./main path\_to\_the\_instance optimal\_value". Then all possibility are use on this instance, for stochastic setting an average is done over 10 run. Depending of the settings of the code execution time,value of solutions or proportional difference is output. This can be chose before compiling by the pre-compilator variable, comment or not, at the beginning of the "main.cpp" file. Values for each settings are separated by ":" in the text output.

To have these result on all instances the multiple\_run.sh script can be use. This bash script will execute the main on each instance and store all results in the res.txt file.\\

To compute few statistic R script have been created :
\begin{itemize}
\item
"compute\_average.R" which compute mean value for each algorithm. Values are taken in the file "tmp.txt", so it can be use to compute both average deviation and computation time. Values are output in the "avg.txt" file.
\item
"compute\_standard\_deviation.R" which calculate standard deviation, it's have been design in the same way as "compute\_average.R" and both take their input in "tmp.txt". Values are output in the "sd.txt" file.
\item
"wilcoxon\_test.R" compute p-value of the wilconxon pairwise test on each pair of column. Beside it compute the Bonferroni correction on each of them. Output table are stoked into the "wilconxon.txt" file. Input file is "tmp.txt".
\end{itemize}

\subsection{Datastructure of a solution}

The solution is represented by a permutation of jobs. It's stored in an static array, the compartment $n$ (we start at the index $0$) store the id of the $n+1$th job to do.

To compute the score we loop on both jobs and machine to compute end date of each jobs on each engine. Then we sum up, with weight, ends date on the last machine. So compute the score of a solution is done in $\Theta(nm)$, where $n$ is the number of jobs and $m$ the number of machine.

Beside, to avoid this too heavy computation time, we design a partial computation function. She use previous computed data to speed up this process. In fact when we compute end date, we store it into the solution's datastructure. And we can notice that end date of a job only depend of the previous one, so if only next one are modified we doesn't need to recompute it, because it doesn't change. In practice this function work like the classical computation of the score but start to compute end date from the index give in parameter, based on previous one. With that the complexity become $O(nm)$.

\subsection{Transpose neighbourhood}

The transpose neighbourhood is composed of all solution that can be reach by exchange of successive jobs. To scan it we just have to test, for all jobs, if the solution in which the job and the next are switch is better.

In practice we loop on jobs, for each one except the last, we switch him with the next one, then compute the score. If it's better than the actual solution we stop, else we switch them again and go to the next job. If the "dofor" mode is activated we doesn't stop, and just go to the next when we improve. If we are in deepest descent we always undo the switch, and if it's better than the best found so far in this scan we note the current index, after we can do this move in $O(1)$.

To avoid to compute the complete score each time we use the "recomputeWCT" function. But it's work only if jobs before the index parameter haven't been change since the previous computation of the score. Before we notice that we always compute the whole score before the loop to have the score of solution passed in parameter. So we just have to do the loop in the reverse order, start by switch last jobs, to be able to use the partial computation all the time.

\subsection{Exchange neighbourhood}

The exchange neighbourhood is composed of all solution that can be reach by exchange to job in the queue. To scan it we have, for each job, to test for all other if their switch improve.

In practice we loop on job, and inside we do an other loop to go all over jobs which are after in the queue. Indeed the switch is identical in both way, and we doesn't want to compute two times each neighbour. If it's better than the actual solution we stop, else we switch them again and go to the next job, when all are test we try to move the next job with next ones. If the "dofor" mode is activated we doesn't stop, and just go to the next when we improve. If we are in deepest descent we always undo the switch, and if it's better than the best found so far in this scan we note currents indexes, after we can do this move in $O(1)$.

With the same idea as before we use the "recomputeWCT" function. And to do it we again do loops in the reverse order, so we try to exchange jobs with previous ones in the queue. But at the end of all second loop we need to fully compute the score to get the good end date table. Indeed we again change last job after work on first one, so the end date table might not be correct (in fact it's correct only if the first job has been change and the switch retain).

TODO le calcul qui montre que le nombre d'op√©ration est moindre.

\subsection{Insert neighbourhood}

The insert neighbourhood is composed by all solution that can be reach by insert a job between two other. To scan it we need, for all jobs, to try all other places in the queue.

In practice we use two loop, the first one go all over jobs, and the second one move it. Indeed try all possible indexes for a job is equal to switch it with the next one (in a cyclic vision, with a modulo) $n$ times. So for all jobs we do this loop, if an improvement is find we stop all, else if move this job isn't worth we use a loop like the second one, but in reverse order, to bring him back at his original position. In the "dofor" mode we do the first loop for all jobs, and the second one run until an improvement (or the end of possibility). So in this mode we need to notice than a job can be move two times in the same call of the function, but we keep it because the solution might don't be the same until we move it again (beside it's not a deepest descent so an improvement can be found even if the solution haven't been change). Finally for the deepest descent we do all loop until the end, keep tracks of indexes of the best improvement, but in this case the application take a $O(n)$ to be done.

Unfortunately the "recompureWCT" function can't be use with this implementation due to cyclic nature of the walk.

\subsection{VND}

The implantation of VND is very classic. It have been implement in a generic way, with an array of neighbourhood to be re-used easily. Finaly we need to notice that the first neighbourhood is used in descent so it's call in a slightly different way to use the "dofor" improvement if the neighbourhood is set for.

\section{Testing}

\subsection{Test's average of neighbourhood}

"tr" point out the transpose neighbourhood, "ex" exchange and "in" for insert. Finally "DD" means we use it int deepest descent. And we need to notice that all these experiment have been done in "dofor" mode.

\begin{table}[!h]
\centering
\begin{tabular}{|*{7}{c|}}
  \hline
  taille & tr & trDD & ex & exDD & in & inDD \\
  \hline
  50 & 31.8 & 32.5 & 4.1 & 4.0 & 6.3 & 6.5 \\ 
  100 & 40.9 & 40.9 & 4.7 & 4.7 & 8.2 & 9.1 \\
  all & 36.3 & 36.7 & 4.4 & 4.3 & 7.3 & 7.8 \\
  \hline
\end{tabular}
\caption{Relative deviation average in \% with random construction}
\label{Relative deviation with random construction}
\end{table}

\begin{table}[!h]
\centering
\begin{tabular}{|*{7}{c|}}
  \hline
  taille & tr & trDD & ex & exDD & in & inDD \\
  \hline
  50 & 27.6 & 27.7 & 4.2 & 4.1 & 5.1 & 5.3 \\ 
  100 & 35.1 & 35.2 & 4.6 & 5.1 & 7.3 & 7.4 \\
  all & 31.3 & 31.4 & 4.4 & 4.6 & 6.2 & 6.3 \\
  \hline
\end{tabular}
\caption{Relative deviation average in \% with rz construction}
\label{Relative deviation with rz construction}
\end{table}

\begin{table}[!h]
\centering
\begin{tabular}{|*{7}{c|}}
  \hline
  taille & tr & trDD & ex & exDD & in & inDD \\
  \hline
  50 & 0.22 & 0.74 & 5.19 & 25.01 & 14.82 & 78.41 \\ 
  100 & 0.93 & 4.80 & 45.58 & 358.2 & 156.1 & 1236 \\
  all & 0.57 & 2.73 & 25.04 & 188.8 & 84.27 & 647.70 \\
  \hline
\end{tabular}
\caption{execution time average with random construction}
\label{Execution time with random construction}
\end{table}

\begin{table}[!h]
\centering
\begin{tabular}{|*{7}{c|}}
  \hline
  taille & tr & trDD & ex & exDD & in & inDD \\
  \hline
  50 & 0.61 & 0.76 & 5.43 & 24.04 & 14.57 & 58.42 \\ 
  100 & 3.91 & 5.12 & 47.37 & 335.6 & 141.3 & 952.6 \\
  all & 2.23 & 2.90 & 26.04 & 177.20 & 76.88 & 497.9 \\
  \hline
\end{tabular}
\caption{execution time average with rz construction}
\label{Execution time with rz construction}
\end{table}

~\\

\subsection{Statistical test of neighbourhood}

We perform the wilcoxon test on score, in a pairwise way, and after applied the Bonferroni correction to the obtained p-value. These result are compiled in the table \ref{Befferoni correction of the wilcoxon pairwise test}. Beside we do the same calculation for the execution time, these results are in the table \ref{Befferoni correction of the wilcoxon pairwise test time}. A population isn't comparable to itself so NaN is used in these cases.

"tr", "ex" and "in" are use in the same way as previously for transpose, exchange and insert. "rnd" is used when the start solution isn't construct, and "rz" when the rz heuristic have been used. "DD" is always here when the descent have been done in deepest descent.

\begin{table}[!h]
\leftskip -2.45cm
{
\footnotesize
\begin{tabular}{|*{13}{c|}}
\hline
~ & rndtr & rndtrDD & rndex & rndexDD & rndin & rndinDD & rztr & rztrDD & rzex & rzexDD & rzin & rzinDD \\
\hline
rndtr & NaN & 1.00 & 9.32e-9 & 9.32e-9 & 9.32e-9 & 9.32e-9 & 9.24e-4 & 3.05e-3 & 9.32e-9 & 9.32e-9 & 9.32e-9 & 9.32e-9 \\
rndtrDD & 1.00 & NaN & 9.32e-9 & 9.32e-9 & 9.32e-9 & 9.32e-9 & 2.64e-4 & 7.39e-4 & 9.32e-9 & 9.32e-9 & 9.32e-9 & 9.32e-9 \\
rndex & 9.32e-9 & 9.32e-9 & NaN & 1.00 & 9.32e-9 & 9.32e-9 & 9.81e-9 & 9.81e-9 & 1.00 & 1.00 & 5.78e-7 & 2.75e-6 \\
rndexDD & 9.32e-9 & 9.32e-9 & 1.00 & NaN & 9.32e-9 & 9.32e-9 & 9.81e-9 & 9.81e-9 & 1.00 & 1.00 & 5.02e-7 & 2.10e-6 \\
rndin & 9.32e-9 & 9.32e-9 & 9.32e-9 & 9.32e-9 & NaN & 5.47e-4 & 9.81e-9 & 9.81e-9 & 2.00e-8 & 9.32e-9 & 1.01e-2 & 3.45e-2 \\
rndinDD & 9.32e-9 & 9.32e-9 & 9.32e-9 & 9.32e-9 & 5.47e-4 & NaN & 9.81e-9 & 9.81e-9 & 1.81e-8 & 9.32e-9 & 3.76e-6 & 1.65e-5 \\
rztr & 9.24e-4 & 2.64e-4 & 9.81e-9 & 9.81e-9 & 9.81e-9 & 9.81e-9 & NaN & 1.00 & 9.32e-9 & 9.32e-9 & 9.32e-9 & 9.32e-9 \\
rztrDD & 3.05e-3 & 7.39e-4 & 9.81e-9 & 9.81e-9 & 9.81e-9 & 9.81e-9 & 1.00 & NaN & 9.32e-9 & 9.32e-9 & 9.32e-9 & 9.32e-9 \\
rzex & 9.32e-9 & 9.32e-9 & 1.00 & 1.00 & 2.00e-8 & 1.81e-8 & 9.32e-9 & 9.32e-9 & NaN & 1.00 & 7.60e-6 & 2.40e-6 \\
rzexDD & 9.32e-9 & 9.32e-9 & 1.00 & 1.00 & 9.32e-9 & 9.32e-9 & 9.32e-9 & 9.32e-9 & 1.00 & NaN & 4.69e-6 & 1.65e-5 \\
rzin & 9.32e-9 & 9.32e-9 & 5.78e-7 & 5.02e-7 & 1.01e-2 & 3.76e-6 & 9.32e-9 & 9.32e-9 & 7.60e-6 & 4.69e-6 & NaN & 1.00 \\
rzinDD & 9.32e-9 & 9.32e-9 & 2.75e-6 & 2.10e-6 & 3.45e-2 & 1.65e-5 & 9.32e-9 & 9.32e-9 & 2.40e-6 & 1.65e-5 & 1.00 & NaN \\
\hline
\end{tabular}
\normalsize
}
\caption{Befferoni correction of the wilcoxon pairwise test, solution quality}
\label{Befferoni correction of the wilcoxon pairwise test}
\end{table}

\begin{table}[!h]
\leftskip -2.45cm
{
\footnotesize
\begin{tabular}{|*{13}{c|}}
\hline
	~ & rndtr & rndtrDD & rndex & rndexDD & rndin & rndinDD & rztr & rztrDD & rzex & rzexDD & rzin & rzinDD \\
  \hline
	rndtr & NaN & 9.32e-9 & 9.32e-9 & 9.32e-9 & 9.32e-9 & 9.32e-9 & 9.32e-9 & 9.32e-9 & 9.32e-9 & 9.32e-9 & 9.32e-9 & 9.32e-9 \\
	rndtrDD & 9.32e-9 & NaN & 9.32e-9 & 9.32e-9 & 9.32e-9 & 9.32e-9 & 1.22e-5 & 1.00 & 9.32e-9 & 9.32e-9 & 9.32e-9 & 9.32e-9 \\
	rndex & 9.32e-9 & 9.32e-9 & NaN & 9.32e-9 & 9.32e-9 & 9.32e-9 & 9.32e-9 & 9.32e-9 & 1.00 & 9.32e-9 & 9.32e-9 & 9.32e-9 \\
	rndexDD & 9.32e-9 & 9.32e-9 & 9.32e-9 & NaN & 9.32e-9 & 9.32e-9 & 9.32e-9 & 9.32e-9 & 9.32e-9 & 1.00 & 9.32e-9 & 1.03e-8 \\
	rndin & 9.32e-9 & 9.32e-9 & 9.32e-9 & 9.32e-9 & NaN & 9.32e-9 & 9.32e-9 & 9.32e-9 & 9.32e-9 & 1.72e-8 & 1.00 & 9.32e-9 \\
	rndinDD & 9.32e-9 & 9.32e-9 & 9.32e-9 & 9.32e-9 & 9.32e-9 & NaN & 9.32e-9 & 9.32e-9 & 9.32e-9 & 9.32e-9 & 9.32e-9 & 2.11e-8 \\
	rztr & 9.32e-9 & 1.22e-5 & 9.32e-9 & 9.32e-9 & 9.32e-9 & 9.32e-9 & NaN & 9.32e-9 & 9.32e-9 & 9.32e-9 & 9.32e-9 & 9.32e-9 \\
	rztrDD & 9.32e-9 & 1.00 & 9.32e-9 & 9.32e-9 & 9.32e-9 & 9.32e-9 & 9.32e-9 & NaN & 9.32e-9 & 9.32e-9 & 9.32e-9 & 9.32e-9 \\
	rzex & 9.32e-9 & 9.32e-9 & 1.00 & 9.32e-9 & 9.32e-9 & 9.32e-9 & 9.32e-9 & 9.32e-9 & NaN & 9.32e-9 & 9.32e-9 & 9.32e-9 \\
	rzexDD & 9.32e-9 & 9.32e-9 & 9.32e-9 & 1.00 & 1.72e-8 & 9.32e-9 & 9.32e-9 & 9.32e-9 & 9.32e-9 & NaN & 1.14e-8 & 9.32e-9 \\
	rzin & 9.32e-9 & 9.32e-9 & 9.32e-9 & 9.32e-9 & 1.00 & 9.32e-9 & 9.32e-9 & 9.32e-9 & 9.32e-9 & 1.14e-8 & NaN & 9.32e-9 \\
	rzinDD & 9.32e-9 & 9.32e-9 & 9.32e-9 & 1.03e-8 & 9.32e-9 & 2.11e-8 & 9.32e-9 & 9.32e-9 & 9.32e-9 & 9.32e-9 & 9.32e-9 & NaN \\

  \hline
\end{tabular}
\normalsize
}
\caption{Befferoni correction of the wilcoxon pairwise test, execution time}
\label{Befferoni correction of the wilcoxon pairwise test time}
\end{table}

~\\

We compute the average of the relative deviation, for all instances and all neighbourhood relation (in deepest descent and first improvement), when we start with a random solution and the rz heuristic. After we compute a pairwise wilcoxon test, compared value are always output by the same algorithm (same neighbourhood, same browsing, different initialisation) on the same instance so what's when a comparison is done only the initialization differ. With a random start the relative deviation average is $16.1 \%$ and with the heuristic it's $14.0 \%$. Finally the Befferoni corrected p-value of the wilcoxon pairwise test is $5.66e^{-15}$. So we can conclude that an initialisation with the rz heuristic is better as a starting point for a local search.

Then the same study have been done with the pivoting rule. With the first improvement the relative deviation average is $15.0 \%$ and with the deepest descent it's $15.2 \%$. But the Befferoni corrected p-value of the wilconxon pairwise test (same idea as before, the only things that differ between two compared value is the pivoting rule) is $0.0004$. Surprisingly the first improvement with a for loop give better result than a deepest descent.

Finally we do this a third time with the neighbourhood relationship. With the transpose relation the relative deviation average (on every pivoting rules and starting point) is $33.9 \%$, with exchange it's $4.4 \%$ and with insert it's $6.9 \%$.
As before a wilconxon pairwise test have been computed, Befferoni corrected p-value are in the table \ref{Befferoni corected wilconxon p-value of neighbourhood}. So with that we can said that exchange is better than insert whichi is better than transpose, and the relation is transitive.

\begin{table}[!h]
\centering
\begin{tabular}{|*{4}{c|}}
  \hline
   & tr & ex & in\\
  \hline
	tr & NaN & 1.10e-39 & 1.10e-39 \\
	ex & 1.10e-39 & NaN & 2.33e-35 \\
	in & 1.10e-39 & 2.33e-35 & NaN \\
  \hline
\end{tabular}
\caption{Befferoni corected wilconxon p-value of neighbourhood, solution quality}
\label{Befferoni corected wilconxon p-value of neighbourhood}
\end{table}

With all of that the best setting might be the exchange neighbourhood browse in first improvement with a for loop starting by the rz heuristic. According to the table \ref{Relative deviation with random construction}, \ref{Relative deviation with rz construction} and \ref{Befferoni correction of the wilcoxon pairwise test} it's true. Except that we can't said that population of result output by other usage of the exchange neighbourhood (with the random start or in deepest descent) are different than the one output by this version. So they might output solution as good as this version.\\

Now go on the executions time point of view.

The average computation time average overall in first improvement is $35.83$ seconds against $252.8$ seconds for the deepest descent. Beside we can notice that for every variant the first improvement version is always faster than the deepest version one, at least until the instance size level (so on average on same instance size first improvement is faster). So no need to a wilcoxon test to understand that the first improvement is clearly faster.

The average computation (over all other settings) time with the transpose neighbourhood is $2.11$ seconds, $104.28$ seconds with exchange and $326.70$ with insert. And the p-value of the pairwise wilconxon test, table \ref{Befferoni corected wilconxon p-value of neighbourhood time}, show that it's absolutely not an average artefact. So the descent in the transpose neighbourhood take clearly less time to reach a local optima, then exchange is slower but faster than insert.
\begin{table}[!h]
\centering
\begin{tabular}{|*{4}{c|}}
  \hline
   & tr & ex & in\\
  \hline
	tr & NaN & 1.1e-39 & 1.1e-39 \\
	ex & 1.1e-39 & NaN & 1.1e-39 \\
	in. & 1.1e-39 & 1.1e-39 & NaN \\
  \hline
\end{tabular}
\caption{Befferoni corected wilconxon p-value of neighbourhood, execution time}
\label{Befferoni corected wilconxon p-value of neighbourhood time}
\end{table}
\subsection{Test's average of VND}

VND1 indicate the VND algorithm which use transpose, then exchange and finish with insert. VND2 is for the one which use transpose, then insert, then exchange. DD mean we use neighbourhoods in deepest descent. Same as previously the transpose neighbourhood is use in "dofor" mode.

\begin{table}[!h]
\centering
\begin{tabular}{|*{5}{c|}}
  \hline
  taille & VND1 & VND1DD & VND2 & VND2DD\\
  \hline
  50 & 3.5 & 3.4 & 4.2 & 4.3 \\ 
  100 & 4.4 & 4.6 & 5.5 & 5.5 \\
  all & 4.0 & 4.0 & 4.9 & 4.9 \\
  \hline
\end{tabular}
\caption{relative deviation average in \% with random construction}
\label{relative deviation of VND with random construction}
\end{table}

\begin{table}[!h]
\centering
\begin{tabular}{|*{5}{c|}}
  \hline
  taille & VND1 & VND1DD & VND2 & VND2DD\\
  \hline
  50 & 3.3 & 3.5 & 3.4 & 3.9 \\ 
  100 & 4.4 & 4.4 & 5.3 & 4.9 \\
  all & 3.9 & 3.9 & 4.3 & 4.4 \\
  \hline
\end{tabular}
\caption{relative deviation average in \% with rz construction}
\label{relative deviation of VND with rz construction}
\end{table}

\begin{table}[!h]
\centering
\begin{tabular}{|*{5}{c|}}
  \hline
  taille & VND1 & VND1DD & VND2 & VND2DD\\
  \hline
  50 & 31.34 & 31.79 & 68.83 & 71.70 \\ 
  100 & 454.0 & 412.5 & 1511 & 1229 \\
  all & 239.1 & 218.9 & 778.0 & 640.8 \\
  \hline
\end{tabular}
\caption{execution time average with random construction}
\label{execution time of VND with random construction}
\end{table}

\begin{table}[!h]
\centering
\begin{tabular}{|*{5}{c|}}
  \hline
  taille & VND1 & VND1DD & VND2 & VND2DD\\
  \hline
  50 & 29.15 & 30.99 & 63.65 & 57.08 \\ 
  100 & 409.8 & 428.8 & 1407 & 1034 \\
  all & 216.2 & 226.5 & 724.2 & 537.6 \\
  \hline
\end{tabular}
\caption{execution time average with rz construction}
\label{execution time of VND with rz construction}
\end{table}

~\\

\begin{table}[!h]
\centering
\begin{tabular}{|*{9}{c|}}
  \hline
   & rndex & rndexDD & rndin & rndinDD & rzex & rzexDD & rzin & rzinDD \\
  \hline
  rndVND1 & 0.42 & 0.38 & 3.17 & 3.66 & 0.42 & 0.61 & 2.15 & 2.27 \\
  rndVND1DD & 0.38 & 0.34 & 3.13 & 3.63 & 0.39 & 0.58 & 2.11 & 2.24 \\
  rzVND1 & 0.53 & 0.48 & 3.28 & 3.77 & 0.53 & 0.72 & 2.25 & 2.38 \\
  rzVND1DD & 0.44 & 0.39 & 3.19 & 3.68 & 0.44 & 0.63 & 2.17 & 2.29 \\
  rndVND2 & -0.43 & -0.47 & 2.28 & 2.77 & -0.43 & -0.24 & 1.27 & 1.40 \\
  rndVND2DD & -0.49 & -0.53 & 2.23 & 2.72 & -0.48 & -0.29 & 1.22 & 1.34 \\
  rzVND2 & 0.09 & 0.04 & 2.82 & 3.32 & 0.09 & 0.28 & 1.80 & 1.93 \\
  rzVND2DD & 0.007 & -0.03 & 2.74 & 3.23 & 0.01 & 0.20 & 1.72 & 1.85 \\
  \hline
\end{tabular}
\caption{relative improvement average of VND to single neighbourhood, in \%}
\label{relative improvement average of VND to single neighbourhood}
\end{table}

~\\

\subsection{Statistical test of VND}
 
We perform the wilcoxon test on score, in a pairwise way, and after applied the Bonferroni correction to the obtained p-value. A population isn't comparable to itself so NaN is used in these cases. First, in the table \ref{Befferoni correction of the wilcoxon pairwise test VND}, VND version are compared to each other. Secondly, in the table \ref{Befferoni correction of the wilcoxon pairwise test VND-single neighbourhood}, VND version are compared to the usage of a single neighbourhood. Finally, after the comparison in term of solution quality, we compared VND version regard of the execution time, result are in the table \ref{Befferoni correction of the wilcoxon pairwise test VND time}.
 
\begin{table}[!h]
\leftskip -1.6cm
{
\footnotesize
\begin{tabular}{|*{9}{c|}}
  \hline
	 & rndVND1 & rndVND1DD & rzVND1 & rzVND1DD & rndVND2 & rndVND2DD & rzVND2 & rzVND2DD \\
  \hline
	rndVND1 & NaN & 1.00 & 1.00 & 1.00 & 2.67e-9 & 2.95e-9 & 0.98 & 0.01 \\
	rndVND1DD & 1.00 & NaN & 1.00 & 1.00 & 2.41e-9 & 1.37e-9 & 0.78 & 0.26 \\
	rzVND1 & 1.00 & 1.00 & NaN & 1.00 & 1.17e-4 & 3.57e-6 & 0.62 & 0.42 \\
	rzVND1DD & 1.00 & 1.00 & 1.00 & NaN & 1.05e-5 & 1.73e-6 & 1.00 & 0.54 \\
	rndVND2 & 2.67e-9 & 2.41e-9 & 1.17e-4 & 1.05e-5 & NaN & 1.00 & 0.20 & 0.15 \\
	rndVND2DD & 2.95e-9 & 1.37e-9 & 3.57e-6 & 1.73e-6 & 1.00 & NaN & 0.08 & 4.78e-3 \\
	rzVND2 & 0.98 & 0.78 & 0.62 & 1.00 & 0.20 & 0.08 & NaN & 1.00 \\
	rzVND2DD & 0.01 & 0.26 & 0.42 & 0.54 & 0.15 & 4.78e-3 & 1.00 & NaN \\
  \hline
\end{tabular}
\normalsize
}
\caption{Befferoni correction of the wilcoxon pairwise test, solution quality}
\label{Befferoni correction of the wilcoxon pairwise test VND}
\end{table} 

\begin{table}[!h]
\leftskip -2.55cm
{
\footnotesize
\begin{tabular}{|*{13}{c|}}
  \hline
	 & rndtr & rndtrDD & rndex & rndexDD & rndin & rndinDD & rztr & rztrDD & rzex & rzexDD & rzin & rzinDD \\
  \hline
	rndVND1 & 9.32e-9 & 9.32e-9 & 0.03 & 1.85e-3 & 9.32e-9 & 9.32e-9 & 9.32e-9 & 9.32e-9 & 1.00 & 0.04 & 2.45e-8 & 2.14e-7 \\
	rndVND1DD & 9.32e-9 & 9.32e-9 & 0.08 & 0.17 & 9.32e-9 & 9.32e-9 & 9.81e-9 & 9.81e-9 & 1.00 & 0.24 & 6.03e-8 & 2.04e-7 \\ 
	rzVND1 & 9.32e-9 & 9.32e-9 & 1.00 & 1.00 & 9.32e-9 & 9.32e-9 & 9.32e-9 & 9.32e-9 & 1.00 & 0.39 & 1.76e-7 & 1.94e-7 \\
	rzVND1DD & 9.32e-9 & 9.32e-9 & 1.00 & 1.00 & 9.81e-9 & 9.32e-9 & 9.32e-9 & 9.32e-9 & 1.00 & 0.16 & 5.51e-7 & 1.38e-7 \\ 
	rndVND2 & 9.32e-9 & 9.32e-9 & 5.27e-4 & 7.71e-5 & 9.32e-9 & 9.32e-9 & 9.81e-9 & 9.81e-9 & 0.55 & 1.00 & 1.06e-4 & 9.43e-5 \\
	rndVND2DD & 9.32e-9 & 9.32e-9 & 1.15e-4 & 6.06e-7 & 9.32e-9 & 9.32e-9 & 9.81e-9 & 9.81e-9 & 0.20 & 1.00 & 7.71e-5 & 9.06e-5 \\ 
	rzVND2 & 9.32e-9 & 9.32e-9 & 1.00 & 1.00 & 9.81e-9 & 9.32e-9 & 9.32e-9 & 9.32e-9 & 1.00 & 1.00 & 3.61e-7 & 1.11e-6 \\
	rzVND2DD & 9.32e-9 & 9.32e-9 & 1.00 & 1.00 & 1.03e-8 & 9.81e-9 & 9.32e-9 & 9.32e-9 & 1.00 & 1.00 & 7.71e-8 & 9.64e-7 \\
  \hline
\end{tabular}
\normalsize
}
\caption{Befferoni correction of the wilcoxon pairwise test, solution quality}
\label{Befferoni correction of the wilcoxon pairwise test VND-single neighbourhood}
\end{table} 

\begin{table}[!h]
\leftskip -1.6cm
{
\footnotesize
\begin{tabular}{|*{9}{c|}}
  \hline
	 & rndVND1 & rndVND1DD & rzVND1 & rzVND1DD & rndVND2 & rndVND2DD & rzVND2 & rzVND2DD \\
  \hline
	rndVND1 & NaN & 1.50e-1 & 1.00 & 1.00 & 9.32e-9 & 9.32e-9 & 1.14e-8 & 1.27e-8 \\
	rndVND1DD & 1.50e-1 & NaN & 1.00 & 1.00 & 9.32e-9 & 9.32e-9 & 1.14e-8 & 1.40e-8 \\
	rzVND1 & 1.00 & 1.00 & NaN & 1.00 & 9.32e-9 & 9.32e-9 & 9.32e-9 & 9.32e-9 \\
	rzVND1DD & 1.00 & 1.00 & 1.00 & NaN & 9.32e-9 & 9.32e-9 & 9.32e-9 & 9.32e-9 \\
	rndVND2 & 9.32e-9 & 9.32e-9 & 9.32e-9 & 9.32e-9 & NaN & 4.16e-2 & 1.00 & 8.10e-8 \\
	rndVND2DD & 9.32e-9 & 9.32e-9 & 9.32e-9 & 9.32e-9 & 4.16e-2 & NaN & 1.00 & 1.02e-4 \\
	rzVND2 & 1.14e-8 & 1.14e-8 & 9.32e-9 & 9.32e-9 & 1.00 & 1.00 & NaN & 5.27e-4 \\
	rzVND2DD & 1.27e-8 & 1.40e-8 & 9.32e-9 & 9.32e-9 & 8.10e-8 & 1.02e-4 & 5.27e-4 & NaN \\
  \hline
\end{tabular}
\normalsize
}
\caption{Befferoni correction of the wilcoxon pairwise test, execution time}
\label{Befferoni correction of the wilcoxon pairwise test VND time}
\end{table} 
 
\section{Conclusion}

\subsection{Best construction heuristic}

\subsection{Best neighbourhood}

\subsection{Best setting for VND}

\subsection{Best solution overall}

\end{document}